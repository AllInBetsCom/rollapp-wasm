// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: archway/callback/v1/events.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// CallbackRegisteredEvent is emitted when a callback is registered.
type CallbackRegisteredEvent struct {
	// contract_address is the address of the contract for which callback is being registered (bech32 encoded).
	ContractAddress string `protobuf:"bytes,1,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"`
	// job_id is an identifier of the callback.
	JobId uint64 `protobuf:"varint,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// callback_height is the height at which the callback is executed.
	CallbackHeight int64 `protobuf:"varint,3,opt,name=callback_height,json=callbackHeight,proto3" json:"callback_height,omitempty"`
	// fee_split is the breakdown of the fees paid by the contract to reserve the callback
	FeeSplit *CallbackFeesFeeSplit `protobuf:"bytes,4,opt,name=fee_split,json=feeSplit,proto3" json:"fee_split,omitempty"`
	// reserved_by is the address which reserved the callback (bech32 encoded).
	ReservedBy string `protobuf:"bytes,5,opt,name=reserved_by,json=reservedBy,proto3" json:"reserved_by,omitempty"`
}

func (m *CallbackRegisteredEvent) Reset()         { *m = CallbackRegisteredEvent{} }
func (m *CallbackRegisteredEvent) String() string { return proto.CompactTextString(m) }
func (*CallbackRegisteredEvent) ProtoMessage()    {}
func (*CallbackRegisteredEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_0196c63f44b94c06, []int{0}
}
func (m *CallbackRegisteredEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CallbackRegisteredEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CallbackRegisteredEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CallbackRegisteredEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CallbackRegisteredEvent.Merge(m, src)
}
func (m *CallbackRegisteredEvent) XXX_Size() int {
	return m.Size()
}
func (m *CallbackRegisteredEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_CallbackRegisteredEvent.DiscardUnknown(m)
}

var xxx_messageInfo_CallbackRegisteredEvent proto.InternalMessageInfo

func (m *CallbackRegisteredEvent) GetContractAddress() string {
	if m != nil {
		return m.ContractAddress
	}
	return ""
}

func (m *CallbackRegisteredEvent) GetJobId() uint64 {
	if m != nil {
		return m.JobId
	}
	return 0
}

func (m *CallbackRegisteredEvent) GetCallbackHeight() int64 {
	if m != nil {
		return m.CallbackHeight
	}
	return 0
}

func (m *CallbackRegisteredEvent) GetFeeSplit() *CallbackFeesFeeSplit {
	if m != nil {
		return m.FeeSplit
	}
	return nil
}

func (m *CallbackRegisteredEvent) GetReservedBy() string {
	if m != nil {
		return m.ReservedBy
	}
	return ""
}

// CallbackCancelledEvent is emitted when a callback is cancelled.
type CallbackCancelledEvent struct {
	// cancelled_by is the address of the contract whose callback is being cancelled (bech32 encoded)
	CancelledBy string `protobuf:"bytes,1,opt,name=cancelled_by,json=cancelledBy,proto3" json:"cancelled_by,omitempty"`
	// contract_address is the address of the contract (bech32 encoded)
	ContractAddress string `protobuf:"bytes,2,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"`
	// job_id is an identifier the callback requestor had passed during registration of the callback
	JobId uint64 `protobuf:"varint,3,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// callback_height is the height at which the callback requestor had registered the callback
	CallbackHeight int64 `protobuf:"varint,4,opt,name=callback_height,json=callbackHeight,proto3" json:"callback_height,omitempty"`
	// refund_amount is the amount of fees which was refunded on cancellation
	RefundAmount types.Coin `protobuf:"bytes,5,opt,name=refund_amount,json=refundAmount,proto3" json:"refund_amount"`
}

func (m *CallbackCancelledEvent) Reset()         { *m = CallbackCancelledEvent{} }
func (m *CallbackCancelledEvent) String() string { return proto.CompactTextString(m) }
func (*CallbackCancelledEvent) ProtoMessage()    {}
func (*CallbackCancelledEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_0196c63f44b94c06, []int{1}
}
func (m *CallbackCancelledEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CallbackCancelledEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CallbackCancelledEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CallbackCancelledEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CallbackCancelledEvent.Merge(m, src)
}
func (m *CallbackCancelledEvent) XXX_Size() int {
	return m.Size()
}
func (m *CallbackCancelledEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_CallbackCancelledEvent.DiscardUnknown(m)
}

var xxx_messageInfo_CallbackCancelledEvent proto.InternalMessageInfo

func (m *CallbackCancelledEvent) GetCancelledBy() string {
	if m != nil {
		return m.CancelledBy
	}
	return ""
}

func (m *CallbackCancelledEvent) GetContractAddress() string {
	if m != nil {
		return m.ContractAddress
	}
	return ""
}

func (m *CallbackCancelledEvent) GetJobId() uint64 {
	if m != nil {
		return m.JobId
	}
	return 0
}

func (m *CallbackCancelledEvent) GetCallbackHeight() int64 {
	if m != nil {
		return m.CallbackHeight
	}
	return 0
}

func (m *CallbackCancelledEvent) GetRefundAmount() types.Coin {
	if m != nil {
		return m.RefundAmount
	}
	return types.Coin{}
}

// CallbackExecutedSuccessEvent is emitted when a callback is executed successfully.
type CallbackExecutedSuccessEvent struct {
	// contract_address is the address of the contract for which callback is being executed (bech32 encoded).
	ContractAddress string `protobuf:"bytes,1,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"`
	// job_id is an identifier of the callback.
	JobId uint64 `protobuf:"varint,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// sudo_msg is the input passed by the module to the contract
	SudoMsg string `protobuf:"bytes,3,opt,name=sudo_msg,json=sudoMsg,proto3" json:"sudo_msg,omitempty"`
	// gas_used is the amount of gas consumed during the callback execution
	GasUsed uint64 `protobuf:"varint,4,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
}

func (m *CallbackExecutedSuccessEvent) Reset()         { *m = CallbackExecutedSuccessEvent{} }
func (m *CallbackExecutedSuccessEvent) String() string { return proto.CompactTextString(m) }
func (*CallbackExecutedSuccessEvent) ProtoMessage()    {}
func (*CallbackExecutedSuccessEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_0196c63f44b94c06, []int{2}
}
func (m *CallbackExecutedSuccessEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CallbackExecutedSuccessEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CallbackExecutedSuccessEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CallbackExecutedSuccessEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CallbackExecutedSuccessEvent.Merge(m, src)
}
func (m *CallbackExecutedSuccessEvent) XXX_Size() int {
	return m.Size()
}
func (m *CallbackExecutedSuccessEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_CallbackExecutedSuccessEvent.DiscardUnknown(m)
}

var xxx_messageInfo_CallbackExecutedSuccessEvent proto.InternalMessageInfo

func (m *CallbackExecutedSuccessEvent) GetContractAddress() string {
	if m != nil {
		return m.ContractAddress
	}
	return ""
}

func (m *CallbackExecutedSuccessEvent) GetJobId() uint64 {
	if m != nil {
		return m.JobId
	}
	return 0
}

func (m *CallbackExecutedSuccessEvent) GetSudoMsg() string {
	if m != nil {
		return m.SudoMsg
	}
	return ""
}

func (m *CallbackExecutedSuccessEvent) GetGasUsed() uint64 {
	if m != nil {
		return m.GasUsed
	}
	return 0
}

// CallbackExecutedFailedEvent is emitted when a callback execution fails.
type CallbackExecutedFailedEvent struct {
	// contract_address is the address of the contract for which callback is being executed (bech32 encoded).
	ContractAddress string `protobuf:"bytes,1,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"`
	// job_id is an identifier of the callback.
	JobId uint64 `protobuf:"varint,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// sudo_msg is the input passed by the module to the contract
	SudoMsg string `protobuf:"bytes,3,opt,name=sudo_msg,json=sudoMsg,proto3" json:"sudo_msg,omitempty"`
	// gas_used is the amount of gas consumed during the callback execution
	GasUsed uint64 `protobuf:"varint,4,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
	// error is the error returned during the callback execution
	Error string `protobuf:"bytes,5,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *CallbackExecutedFailedEvent) Reset()         { *m = CallbackExecutedFailedEvent{} }
func (m *CallbackExecutedFailedEvent) String() string { return proto.CompactTextString(m) }
func (*CallbackExecutedFailedEvent) ProtoMessage()    {}
func (*CallbackExecutedFailedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_0196c63f44b94c06, []int{3}
}
func (m *CallbackExecutedFailedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CallbackExecutedFailedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CallbackExecutedFailedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CallbackExecutedFailedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CallbackExecutedFailedEvent.Merge(m, src)
}
func (m *CallbackExecutedFailedEvent) XXX_Size() int {
	return m.Size()
}
func (m *CallbackExecutedFailedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_CallbackExecutedFailedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_CallbackExecutedFailedEvent proto.InternalMessageInfo

func (m *CallbackExecutedFailedEvent) GetContractAddress() string {
	if m != nil {
		return m.ContractAddress
	}
	return ""
}

func (m *CallbackExecutedFailedEvent) GetJobId() uint64 {
	if m != nil {
		return m.JobId
	}
	return 0
}

func (m *CallbackExecutedFailedEvent) GetSudoMsg() string {
	if m != nil {
		return m.SudoMsg
	}
	return ""
}

func (m *CallbackExecutedFailedEvent) GetGasUsed() uint64 {
	if m != nil {
		return m.GasUsed
	}
	return 0
}

func (m *CallbackExecutedFailedEvent) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func init() {
	proto.RegisterType((*CallbackRegisteredEvent)(nil), "archway.callback.v1.CallbackRegisteredEvent")
	proto.RegisterType((*CallbackCancelledEvent)(nil), "archway.callback.v1.CallbackCancelledEvent")
	proto.RegisterType((*CallbackExecutedSuccessEvent)(nil), "archway.callback.v1.CallbackExecutedSuccessEvent")
	proto.RegisterType((*CallbackExecutedFailedEvent)(nil), "archway.callback.v1.CallbackExecutedFailedEvent")
}

func init() { proto.RegisterFile("archway/callback/v1/events.proto", fileDescriptor_0196c63f44b94c06) }

var fileDescriptor_0196c63f44b94c06 = []byte{
	// 531 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x53, 0xcd, 0x6e, 0xd3, 0x4c,
	0x14, 0xcd, 0x34, 0x49, 0xdb, 0x4c, 0xfa, 0x7d, 0x45, 0xa6, 0x40, 0x52, 0x90, 0x1b, 0xb2, 0x21,
	0x5d, 0x60, 0x2b, 0x45, 0x3c, 0x40, 0x13, 0x1a, 0xc1, 0x02, 0x21, 0xb9, 0x62, 0xc3, 0xc6, 0x1a,
	0xcf, 0xdc, 0x38, 0x2e, 0xb6, 0x27, 0x9a, 0x3b, 0x4e, 0x63, 0x9e, 0x82, 0x15, 0x2f, 0xc1, 0x8b,
	0x74, 0xd9, 0x25, 0x2b, 0x84, 0x92, 0x2d, 0xbc, 0x03, 0xf2, 0x5f, 0x91, 0x50, 0xa4, 0x4a, 0xa8,
	0xbb, 0xb9, 0xe7, 0xde, 0x63, 0x9f, 0x73, 0xee, 0x0c, 0xed, 0x31, 0xc5, 0x67, 0x97, 0x2c, 0xb5,
	0x39, 0x0b, 0x43, 0x8f, 0xf1, 0x8f, 0xf6, 0x62, 0x68, 0xc3, 0x02, 0x62, 0x8d, 0xd6, 0x5c, 0x49,
	0x2d, 0x8d, 0xfb, 0xe5, 0x84, 0x55, 0x4d, 0x58, 0x8b, 0xe1, 0x61, 0x7f, 0x13, 0xed, 0x66, 0x20,
	0x27, 0x1e, 0x1e, 0xf8, 0xd2, 0x97, 0xf9, 0xd1, 0xce, 0x4e, 0x25, 0x6a, 0x72, 0x89, 0x91, 0x44,
	0xdb, 0x63, 0x08, 0xf6, 0x62, 0xe8, 0x81, 0x66, 0x43, 0x9b, 0xcb, 0x20, 0x2e, 0xfb, 0xdd, 0xa2,
	0xef, 0x16, 0xc4, 0xa2, 0x28, 0x5a, 0xfd, 0x5f, 0x84, 0x3e, 0x1a, 0x97, 0xff, 0x70, 0xc0, 0x0f,
	0x50, 0x83, 0x02, 0x71, 0x96, 0x89, 0x35, 0x8e, 0xe9, 0x3d, 0x2e, 0x63, 0xad, 0x18, 0xd7, 0x2e,
	0x13, 0x42, 0x01, 0x62, 0x87, 0xf4, 0xc8, 0xa0, 0xe5, 0xec, 0x57, 0xf8, 0x69, 0x01, 0x1b, 0x0f,
	0xe8, 0xf6, 0x85, 0xf4, 0xdc, 0x40, 0x74, 0xb6, 0x7a, 0x64, 0xd0, 0x70, 0x9a, 0x17, 0xd2, 0x7b,
	0x23, 0x8c, 0x67, 0x74, 0xbf, 0x32, 0xe0, 0xce, 0x20, 0xf0, 0x67, 0xba, 0x53, 0xef, 0x91, 0x41,
	0xdd, 0xf9, 0xbf, 0x82, 0x5f, 0xe7, 0xa8, 0x31, 0xa1, 0xad, 0x29, 0x80, 0x8b, 0xf3, 0x30, 0xd0,
	0x9d, 0x46, 0x8f, 0x0c, 0xda, 0x27, 0xc7, 0xd6, 0x86, 0x90, 0xac, 0x4a, 0xeb, 0x04, 0x00, 0x27,
	0x00, 0xe7, 0x19, 0xc1, 0xd9, 0x9d, 0x96, 0x27, 0xe3, 0x88, 0xb6, 0x15, 0x20, 0xa8, 0x05, 0x08,
	0xd7, 0x4b, 0x3b, 0xcd, 0x5c, 0x2d, 0xad, 0xa0, 0x51, 0xda, 0xff, 0x49, 0xe8, 0xc3, 0xea, 0x1b,
	0x63, 0x16, 0x73, 0x08, 0xc3, 0xca, 0xee, 0x53, 0xba, 0xc7, 0x2b, 0x24, 0x23, 0x17, 0x56, 0xdb,
	0x37, 0xd8, 0x28, 0xdd, 0x98, 0xc8, 0xd6, 0x6d, 0x89, 0xd4, 0x6f, 0x49, 0xa4, 0xb1, 0x31, 0x91,
	0x57, 0xf4, 0x3f, 0x05, 0xd3, 0x24, 0x16, 0x2e, 0x8b, 0x64, 0x12, 0xeb, 0xdc, 0x4b, 0xfb, 0xa4,
	0x6b, 0x95, 0xeb, 0xcb, 0x76, 0x6d, 0x95, 0xbb, 0xb6, 0xc6, 0x32, 0x88, 0x47, 0x8d, 0xab, 0xef,
	0x47, 0x35, 0x67, 0xaf, 0x60, 0x9d, 0xe6, 0xa4, 0xfe, 0x17, 0x42, 0x9f, 0x54, 0x76, 0xcf, 0x96,
	0xc0, 0x13, 0x0d, 0xe2, 0x3c, 0xe1, 0x1c, 0x10, 0xef, 0x6a, 0xc7, 0x5d, 0xba, 0x8b, 0x89, 0x90,
	0x6e, 0x84, 0x7e, 0x6e, 0xb5, 0xe5, 0xec, 0x64, 0xf5, 0x5b, 0xf4, 0xb3, 0x96, 0xcf, 0xd0, 0x4d,
	0x10, 0x44, 0xee, 0xb2, 0xe1, 0xec, 0xf8, 0x0c, 0xdf, 0x23, 0x88, 0xfe, 0x57, 0x42, 0x1f, 0xff,
	0x2d, 0x6c, 0xc2, 0x82, 0xf0, 0xee, 0xee, 0xde, 0x3f, 0xe9, 0x32, 0x0e, 0x68, 0x13, 0x94, 0x92,
	0xaa, 0xbc, 0x3a, 0x45, 0x31, 0x7a, 0x77, 0xb5, 0x32, 0xc9, 0xf5, 0xca, 0x24, 0x3f, 0x56, 0x26,
	0xf9, 0xbc, 0x36, 0x6b, 0xd7, 0x6b, 0xb3, 0xf6, 0x6d, 0x6d, 0xd6, 0x3e, 0xbc, 0xf4, 0x03, 0x3d,
	0x4b, 0x3c, 0x8b, 0xcb, 0xc8, 0x16, 0x69, 0x04, 0x31, 0x06, 0x32, 0x5e, 0xa6, 0x9f, 0x6c, 0x25,
	0xc3, 0x90, 0xcd, 0xe7, 0xcf, 0x2f, 0x19, 0x46, 0xf6, 0xf2, 0xcf, 0x9b, 0xd6, 0xe9, 0x1c, 0xd0,
	0xdb, 0xce, 0x5f, 0xdf, 0x8b, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x7e, 0x15, 0x7c, 0x6b, 0x2b,
	0x04, 0x00, 0x00,
}

func (m *CallbackRegisteredEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallbackRegisteredEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CallbackRegisteredEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReservedBy) > 0 {
		i -= len(m.ReservedBy)
		copy(dAtA[i:], m.ReservedBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ReservedBy)))
		i--
		dAtA[i] = 0x2a
	}
	if m.FeeSplit != nil {
		{
			size, err := m.FeeSplit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CallbackHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.CallbackHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.JobId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.JobId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ContractAddress) > 0 {
		i -= len(m.ContractAddress)
		copy(dAtA[i:], m.ContractAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ContractAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CallbackCancelledEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallbackCancelledEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CallbackCancelledEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RefundAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.CallbackHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.CallbackHeight))
		i--
		dAtA[i] = 0x20
	}
	if m.JobId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.JobId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ContractAddress) > 0 {
		i -= len(m.ContractAddress)
		copy(dAtA[i:], m.ContractAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ContractAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CancelledBy) > 0 {
		i -= len(m.CancelledBy)
		copy(dAtA[i:], m.CancelledBy)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.CancelledBy)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CallbackExecutedSuccessEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallbackExecutedSuccessEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CallbackExecutedSuccessEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GasUsed != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.GasUsed))
		i--
		dAtA[i] = 0x20
	}
	if len(m.SudoMsg) > 0 {
		i -= len(m.SudoMsg)
		copy(dAtA[i:], m.SudoMsg)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SudoMsg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.JobId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.JobId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ContractAddress) > 0 {
		i -= len(m.ContractAddress)
		copy(dAtA[i:], m.ContractAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ContractAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CallbackExecutedFailedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallbackExecutedFailedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CallbackExecutedFailedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x2a
	}
	if m.GasUsed != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.GasUsed))
		i--
		dAtA[i] = 0x20
	}
	if len(m.SudoMsg) > 0 {
		i -= len(m.SudoMsg)
		copy(dAtA[i:], m.SudoMsg)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SudoMsg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.JobId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.JobId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ContractAddress) > 0 {
		i -= len(m.ContractAddress)
		copy(dAtA[i:], m.ContractAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ContractAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CallbackRegisteredEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.JobId != 0 {
		n += 1 + sovEvents(uint64(m.JobId))
	}
	if m.CallbackHeight != 0 {
		n += 1 + sovEvents(uint64(m.CallbackHeight))
	}
	if m.FeeSplit != nil {
		l = m.FeeSplit.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ReservedBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *CallbackCancelledEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CancelledBy)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ContractAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.JobId != 0 {
		n += 1 + sovEvents(uint64(m.JobId))
	}
	if m.CallbackHeight != 0 {
		n += 1 + sovEvents(uint64(m.CallbackHeight))
	}
	l = m.RefundAmount.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *CallbackExecutedSuccessEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.JobId != 0 {
		n += 1 + sovEvents(uint64(m.JobId))
	}
	l = len(m.SudoMsg)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.GasUsed != 0 {
		n += 1 + sovEvents(uint64(m.GasUsed))
	}
	return n
}

func (m *CallbackExecutedFailedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.JobId != 0 {
		n += 1 + sovEvents(uint64(m.JobId))
	}
	l = len(m.SudoMsg)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.GasUsed != 0 {
		n += 1 + sovEvents(uint64(m.GasUsed))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CallbackRegisteredEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallbackRegisteredEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallbackRegisteredEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			m.JobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallbackHeight", wireType)
			}
			m.CallbackHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CallbackHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FeeSplit == nil {
				m.FeeSplit = &CallbackFeesFeeSplit{}
			}
			if err := m.FeeSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReservedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallbackCancelledEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallbackCancelledEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallbackCancelledEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelledBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CancelledBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			m.JobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallbackHeight", wireType)
			}
			m.CallbackHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CallbackHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefundAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RefundAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallbackExecutedSuccessEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallbackExecutedSuccessEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallbackExecutedSuccessEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			m.JobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SudoMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SudoMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
			}
			m.GasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallbackExecutedFailedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallbackExecutedFailedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallbackExecutedFailedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			m.JobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SudoMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SudoMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
			}
			m.GasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
